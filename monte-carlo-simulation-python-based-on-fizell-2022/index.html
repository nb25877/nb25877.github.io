<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Monte Carlo Simulation (Python) Based on Fizell (2022) - E-Portfolio</title><meta name="description" content="To understand how to model risks with high variance, I developed a Python script using numpy and pandas to run a Monte Carlo simulation. Instead of relying on a single 'average' prediction for future risk exposure (e.g., potential financial loss), the simulation generated 1,000 random&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://nb25877.github.io/monte-carlo-simulation-python-based-on-fizell-2022/"><link rel="alternate" type="application/atom+xml" href="https://nb25877.github.io/feed.xml" title="E-Portfolio - RSS"><link rel="alternate" type="application/json" href="https://nb25877.github.io/feed.json" title="E-Portfolio - JSON"><meta property="og:title" content="Monte Carlo Simulation (Python) Based on Fizell (2022)"><meta property="og:site_name" content="E-Portfolio"><meta property="og:description" content="To understand how to model risks with high variance, I developed a Python script using numpy and pandas to run a Monte Carlo simulation. Instead of relying on a single 'average' prediction for future risk exposure (e.g., potential financial loss), the simulation generated 1,000 random&hellip;"><meta property="og:url" content="https://nb25877.github.io/monte-carlo-simulation-python-based-on-fizell-2022/"><meta property="og:type" content="article"><link rel="stylesheet" href="https://nb25877.github.io/assets/css/style.css?v=2110fdcc9616a96348b5f5ad11c64055"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://nb25877.github.io/monte-carlo-simulation-python-based-on-fizell-2022/"},"headline":"Monte Carlo Simulation (Python) Based on Fizell (2022)","datePublished":"2026-01-22T12:56+04:00","dateModified":"2026-01-29T15:59+04:00","description":"To understand how to model risks with high variance, I developed a Python script using numpy and pandas to run a Monte Carlo simulation. Instead of relying on a single 'average' prediction for future risk exposure (e.g., potential financial loss), the simulation generated 1,000 random&hellip;","author":{"@type":"Person","name":"Nikunj Bhalotia","url":"https://nb25877.github.io/authors/nikunj-bhalotia/"},"publisher":{"@type":"Organization","name":"Nikunj Bhalotia"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://nb25877.github.io/">E-Portfolio</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://nb25877.github.io/security-and-risk-management/" title="Security and Risk Management" target="_self">Security and Risk Management</a></li><li><a href="https://nb25877.github.io/advanced-object-oriented-design-and-programming/" title="Advanced Object Oriented Design and Programming" target="_self">Advanced Object Oriented Design and Programming</a></li><li><a href="https://nb25877.github.io/network-security/" title="Network Security" target="_self">Network Security</a></li><li><a href="https://nb25877.github.io/induction-computing/" title="Induction Computing" target="_self">Induction Computing</a></li></ul></nav></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Monte Carlo Simulation (Python) Based on Fizell (2022)</h1><div class="feed__meta content__meta"><a href="https://nb25877.github.io/authors/nikunj-bhalotia/" class="feed__author">Nikunj Bhalotia</a> <time datetime="2026-01-22T12:56" class="feed__date">January 22, 2026</time></div></div></header></div><div class="entry-wrapper content__entry"><p>To understand how to model risks with high variance, I developed a Python script using <code>numpy</code> and <code>pandas</code> to run a Monte Carlo simulation. Instead of relying on a single "average" prediction for future risk exposure (e.g., potential financial loss), the simulation generated <strong>1,000 random iterations</strong> based on historical volatility.</p><ul class="wp-block-list"><li><strong>Key Concept Applied:</strong> The script used <code>norm.ppf</code> (Percent Point Function) to generate random variables within a specified mean and standard deviation, effectively simulating "black swan" events and best/worst-case scenarios.</li><li><strong>Outcome:</strong> The output provided a probability distribution rather than a single number. This allowed me to state with <strong>95% confidence</strong> that the potential risk exposure would fall within a specific range, providing a far more defensible metric for stakeholders than a "High/Medium/Low" label.</li></ul><p>Description: This script simulates 1,000 potential outcomes for a financial risk scenario (e.g., cost of a data breach) using historical volatility data. It calculates the 95% confidence interval (Value at Risk).</p><pre class="wp-block-code"><code>import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import norm

# --- CONFIGURATION ---
# Scenario: Estimating potential financial loss from a supply chain disruption
# Based on historical data, we assume a normal distribution of daily loss.
simulations = 1000          # Number of iterations
days_to_forecast = 30       # Duration of the risk event
avg_daily_loss = 5000       # Mean daily loss in GBP
std_dev_loss = 1500         # Volatility (Standard Deviation)

# --- MONTE CARLO SIMULATION ---
def run_simulation():
    results = &#091;]
    
    for i in range(simulations):
        # Generate random daily losses based on normal distribution
        # norm.ppf converts a random percentage (0-1) to a value on the distribution curve
        daily_losses = norm.ppf(np.random.rand(days_to_forecast), loc=avg_daily_loss, scale=std_dev_loss)
        
        # Cumulative sum of losses for this 30-day iteration
        total_event_cost = daily_losses.sum()
        results.append(total_event_cost)
    
    return np.array(results)

# --- EXECUTION &#038; ANALYSIS ---
simulated_costs = run_simulation()

# Calculate Key Metrics
mean_cost = np.mean(simulated_costs)
worst_case = np.percentile(simulated_costs, 95) # 95th percentile (Value at Risk)
best_case = np.percentile(simulated_costs, 5)   # 5th percentile

print(f&#034;--- RISK FORECAST (30 DAYS) ---&#034;)
print(f&#034;Mean Expected Cost: £{mean_cost:,.2f}&#034;)
print(f&#034;95% Confidence Worst Case: £{worst_case:,.2f}&#034;)
print(f&#034;5% Confidence Best Case: £{best_case:,.2f}&#034;)

# Optional: Visualization code would go here
# plt.hist(simulated_costs, bins=50)</code></pre><h2 class="wp-block-heading">References:</h2><p>Fizell, Z. (2022) <em>How to Create a Monte Carlo Simulation using Python</em>. Available at: <a href="https://towardsdatascience.com/how-to-create-a-monte-carlo-simulation-using-python-c24634a0978a/" target="_blank" rel="noreferrer noopener">https://towardsdatascience.com/how-to-create-a-monte-carlo-simulation-using-python-c24634a0978a/</a></p></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on January 29, 2026</p><div class="content__actions"><ul class="content__tag"><li><a href="https://nb25877.github.io/tags/ai/">ai</a></li><li><a href="https://nb25877.github.io/tags/artificial-intelligence/">artificial-intelligence</a></li><li><a href="https://nb25877.github.io/tags/data-science/">data-science</a></li><li><a href="https://nb25877.github.io/tags/machine-learning/">machine-learning</a></li><li><a href="https://nb25877.github.io/tags/technology/">technology</a></li></ul><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://nb25877.github.io/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://nb25877.github.io/authors/nikunj-bhalotia/" rel="author">Nikunj Bhalotia</a></h3></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://nb25877.github.io/gdpr-case-study-analysis-social-engineering-attack/" class="content__nav-link" rel="prev"><div><span>Previous</span> GDPR Case Study Analysis: Social Engineering Attack</div></a></div><div class="content__nav-next"><a href="https://nb25877.github.io/bayesian-risk-update-think-bayes-2-based-on-downey-2022-chapters-1-andamp-2/" class="content__nav-link" rel="next"><div><span>Next</span> Bayesian Risk Update (Think Bayes 2) Based on Downey (2022), Chapters 1 &amp;amp; 2</div></a></div></div></div></nav></footer></article><div class="content__related related"><div class="wrapper"><h2 class="h4 related__title">You should also read:</h2><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://nb25877.github.io/authors/nikunj-bhalotia/" class="feed__author">Nikunj Bhalotia</a> <time datetime="2026-01-22T14:27" class="feed__date">January 22, 2026</time></div><h3 class="feed__title"><a href="https://nb25877.github.io/modelling-social-engineering-threats-based-on-aijaz-m-and-nazir-m-2024/">Modelling Social Engineering Threats Based on Aijaz, M. and Nazir, M. (2024)</a></h3></header><p>1. What are the main challenges in modelling and evaluating the outcomes of Social Engineering Threats (SETs), and how does this study address them? The primary challenge in modelling SETs is the inherent unpredictability of human behavior, which makes rigorous mathematical evaluation difficult. Unlike technical&hellip;</p><a href="https://nb25877.github.io/modelling-social-engineering-threats-based-on-aijaz-m-and-nazir-m-2024/" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://nb25877.github.io/authors/nikunj-bhalotia/" class="feed__author">Nikunj Bhalotia</a> <time datetime="2026-01-22T13:21" class="feed__date">January 22, 2026</time></div><h3 class="feed__title"><a href="https://nb25877.github.io/bayesian-risk-update-think-bayes-2-based-on-downey-2022-chapters-1-andamp-2/">Bayesian Risk Update (Think Bayes 2) Based on Downey (2022), Chapters 1 &amp;amp; 2</a></h3></header><p>I used Allen Downey’s ThinkBayes2 library to practice Diachronic Bayes, the process of updating a hypothesis ($H$) based on new data (D). Description: This script adapts the 'Think Bayes' methodology to a security context. It updates the probability of a specific threat (Hypothesis) being active&hellip;</p><a href="https://nb25877.github.io/bayesian-risk-update-think-bayes-2-based-on-downey-2022-chapters-1-andamp-2/" class="readmore feed__readmore">Continue reading...</a></div></article></div></div></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright"><p>Nikunj Bhalotia</p></div><button id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://nb25877.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://nb25877.github.io/assets/js/scripts.min.js?v=d0fc1030089a37f93a2d51bf6d07565c"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>